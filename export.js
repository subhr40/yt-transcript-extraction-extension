/**
 * Export.js: Handle PDF and Markdown exports
 */

class ExportManager {
    constructor() {
        this.jsPDFLoaded = false;
        this.loadJsPDF();
    }

    async loadJsPDF() {
        if(this.jsPDFLoaded) return;

        try {
            // Load PDF from CDN
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            script.onload = () => {
                this.jsPDFLoaded = true;
                console.log(`PDF loaded successfully`);
            };
            document.head.appendChild(script);
        } catch(error){
            console.error(`Failed to load PDF ${error}`);
        }
    }

    async exportToPDF(summaryData) {
        if(!this.jsPDFLoaded || !window.jsPDF) {
            throw new Error("PDF export library not loaded");
        }
        try {
            const { jsPDF } = window.jsPDF;
            const doc = new jsPDF();

            // Set up styling
            const margin = 20;
            const pageWidth = doc.internal.pageSize.getWidth();
            const contentWidth = pageWidth - (margin * 2);

            let currentY = margin;

            // Header
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text('YouTube Video Summary', margin, currentY);
            currentY += 15;

            // Video Info
            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');

            if(summaryData.title) {
                doc.setFont(undefined, 'bold');
                doc.text('Title:', margin, currentY);
                doc.setFont(undefined, 'normal');
                const titleLines = doc.splitTextToSize(summaryData.title, contentWidth - 30);
                doc.text(titleLines, margin + 30, currentY);
                currentY += (titleLines.length * 5) + 5;
            }

            if(summaryData.channel) {
                doc.setFont(undefined, 'bold');
                doc.text('Channel:', margin, currentY);
                doc.setFont(undefined, 'normal');
                doc.text(summaryData.channel, margin + 35, currentY);
                currentY += 10;
            }

            if(summaryData.duration) {
                doc.setFont(undefined, 'bold');
                doc.text('Duration: ', margin, currentY);
                doc.setFont(undefined, 'normal');
                doc.text(summaryData.duration, margin + 35, currentY);
                currentY += 10;
            }

            if (summaryData.url) {
                doc.setFont(undefined, 'bold');
                doc.text('URL:', margin, currentY);
                doc.setFont(undefined, 'normal');
                const urlLines = doc.splitTextToSize(summaryData.url, contentWidth - 25);
                doc.text(urlLines, margin + 25, currentY);
                currentY += (urlLines.length * 5) + 10;
            }

            // Summary Type
            doc.setFont(undefined, 'bold');
            doc.setFontSize(14);
            doc.text('Summary', margin, currentY);
            currentY += 10;

            doc.setFont(undefined, 'normal');
            doc.setFontSize(11);

            const summaryLines = doc.splitTextToSizes(summaryData.content, contentWidth);

            summaryLines.forEach(line => {
                if(currentY > doc.internal.pageSize.getHeight() - margin) {
                    doc.addPage();
                    currentY = margin;
                }
                doc.text(line, margin, currentY);
                currentY += 5;
            });

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1;i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setFont(undefined, 'normal');
                doc.text(
                    `Generated by YT Summarizer - ${new Date().toLocaleDateString()} - Page ${i}/${pageCount}`,
                    margin,
                    doc.internal.pageSize.getHeight() - 10
                );
            }

            // Save PDF
            const fileName = this.generatedFileName(summaryData.title, 'pdf');
            doc.save(filename);

            return { success: true, fileName };

        } catch(error) {
            console.error(`PDF Export Error: ${error}`);
            throw error;
        }
    }

    // Export summary as markdown
    exportToMarkdown(summaryData) {
        try {
            let markdown = '';

            // Header
            markdown += '#YouTube Video Summary\n\n';

            // Video Information
            if(summaryData.title) {
                markdown += `**Title** ${summaryData.title}\n\n`;
            }

            if(summaryData.channel) {
                markdown += `**Channel** ${summaryData.channel}\n\n`;
            }

            if(summaryData.duration) {
                markdown += `**Duration** ${summaryData.duration}\n\n`;
            }

            if(summaryData.url) {
                markdown += `**URL** [${summaryData.url}](${summaryData.url})\n\n`
            }

            markdown += `**Summary Type** ${this.formatSummaryType(summaryData.summaryType)}\n\n`;
            markdown += `**Generated:** ${new Date().toLocaleDateString()}\n\n`;

            markdown += ` ---- \n\n`;

            // Summary content
            markdown += `##Summary\n\n`;
            markdown += this.formatContentForMarkdown(summaryData.content, summaryData.summaryType);

            // Additional sections if available
            if (summaryData.keyPoints) {
                markdown += '\n\n## Key Points\n\n';
                summaryData.keyPoints.forEach(point => {
                    markdown += `- ${point}\n`;
                });
            }
            
            if (summaryData.questions) {
                markdown += '\n\n## Quiz Questions\n\n';
                summaryData.questions.forEach((q, index) => {
                    markdown += `${index + 1}. ${q.question}\n`;
                    if (q.answer) {
                        markdown += `   **Answer:** ${q.answer}\n\n`;
                    }
                });
            }
            
            markdown += '\n---\n';
            markdown += '*Generated by YT Transcript Summarizer*';
            
            // Download the markdown file
            const fileName = this.generateFileName(summaryData.title, 'md');
            this.downloadTextFile(markdown, fileName, 'text/markdown');
            
            return { success: true, fileName };

        } catch(error) {
            console.error(`Markdown Export Error: ${error}`);
            throw error;
        }
    }

    // Format content based on summary type
    formatContentForMarkdown(content, summaryType) {
        switch (summaryType) {
            case 'bullet-points':
                // If content already has bullet points, preserve them
                if (content.includes('â€¢') || content.includes('-')) {
                    return content;
                }
                // Otherwise, convert sentences to bullet points
                return content.split('. ').map(sentence => `- ${sentence.trim()}`).join('\n');
                
            case 'outline':
                // Convert to markdown outline format
                return content.replace(/(\d+\.)/g, '\n$1').replace(/([a-z]\))/g, '  $1');
                
            case 'qa':
                // Format Q&A pairs
                return content.replace(/(Q:|Question:)/gi, '\n**Q:**').replace(/(A:|Answer:)/gi, '\n**A:**');
                
            case 'timeline':
                // Format timeline entries
                return content.replace(/(\d+:\d+)/g, '\n**$1**');
                
            default:
                return content;
        }
    }

    // Export summary as plain text
    exportToText(summaryData) {
        try {
            let text = 'YOUTUBE VIDEO SUMMARY\n';
            text += '='.repeat(50) + '\n\n';
            
            if (summaryData.title) {
                text += `Title: ${summaryData.title}\n`;
            }
            
            if (summaryData.channel) {
                text += `Channel: ${summaryData.channel}\n`;
            }
            
            if (summaryData.duration) {
                text += `Duration: ${summaryData.duration}\n`;
            }
            
            if (summaryData.url) {
                text += `URL: ${summaryData.url}\n`;
            }
            
            text += `Summary Type: ${this.formatSummaryType(summaryData.summaryType)}\n`;
            text += `Generated: ${new Date().toLocaleString()}\n\n`;
            
            text += '-'.repeat(50) + '\n\n';
            text += 'SUMMARY:\n\n';
            text += summaryData.content;
            
            text += '\n\n' + '-'.repeat(50);
            text += '\nGenerated by YT Transcript Summarizer';
            
            const fileName = this.generateFileName(summaryData.title, 'txt');
            this.downloadTextFile(text, fileName, 'text/plain');
            
            return { success: true, fileName };
            
        } catch (error) {
            console.error('Text export error:', error);
            throw error;
        }
    }

    // Export to JSON (for backup/import)
    exportToJSON(summaryData) {
        try {
            const jsonData = {
                ...summaryData,
                exportedAt: new Date().toISOString(),
                version: '1.0'
            };
            
            const fileName = this.generateFileName(summaryData.title, 'json');
            this.downloadTextFile(
                JSON.stringify(jsonData, null, 2), 
                fileName, 
                'application/json'
            );
            
            return { success: true, fileName };
            
        } catch (error) {
            console.error('JSON export error:', error);
            throw error;
        }
    }

    // Batch export multiple summaries
    async exportBatch(summaries, format = 'markdown') {
        try {
            if (format === 'pdf') {
                return await this.exportBatchToPDF(summaries);
            } else if (format === 'markdown') {
                return this.exportBatchToMarkdown(summaries);
            } else if (format === 'json') {
                return this.exportBatchToJSON(summaries);
            }
        } catch (error) {
            console.error('Batch export error:', error);
            throw error;
        }
    }

    async exportBatchToPDF(summaries) {
        if (!this.jsPDFLoaded || !window.jsPDF) {
            throw new Error('PDF export library not loaded');
        }

        const { jsPDF } = window.jsPDF;
        const doc = new jsPDF();
        const margin = 20;
        let currentY = margin;
        
        // Title page
        doc.setFontSize(24);
        doc.setFont(undefined, 'bold');
        doc.text('YouTube Summaries Collection', margin, currentY);
        currentY += 20;
        
        doc.setFontSize(12);
        doc.setFont(undefined, 'normal');
        doc.text(`Generated: ${new Date().toLocaleString()}`, margin, currentY);
        doc.text(`Total Summaries: ${summaries.length}`, margin, currentY + 10);
        
        // Add each summary
        for (let i = 0; i < summaries.length; i++) {
            doc.addPage();
            currentY = margin;
            
            const summary = summaries[i];
            
            // Summary header
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text(`Summary ${i + 1}`, margin, currentY);
            currentY += 15;
            
            // Add summary content using the same logic as single export
            await this.addSummaryToPDF(doc, summary, margin, currentY);
        }
        
        const fileName = `yt-summaries-batch-${Date.now()}.pdf`;
        doc.save(fileName);
        
        return { success: true, fileName, count: summaries.length };
    }

    exportBatchToMarkdown(summaries) {
        let markdown = '# YouTube Summaries Collection\n\n';
        markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
        markdown += `**Total Summaries:** ${summaries.length}\n\n`;
        markdown += '---\n\n';
        
        summaries.forEach((summary, index) => {
            markdown += `## Summary ${index + 1}\n\n`;
            
            if (summary.title) {
                markdown += `**Title:** ${summary.title}\n`;
            }
            if (summary.channel) {
                markdown += `**Channel:** ${summary.channel}\n`;
            }
            if (summary.url) {
                markdown += `**URL:** [${summary.url}](${summary.url})\n`;
            }
            
            markdown += `**Type:** ${this.formatSummaryType(summary.summaryType)}\n\n`;
            markdown += this.formatContentForMarkdown(summary.content, summary.summaryType);
            markdown += '\n\n---\n\n';
        });
        
        markdown += '*Generated by YT Transcript Summarizer*';
        
        const fileName = `yt-summaries-batch-${Date.now()}.md`;
        this.downloadTextFile(markdown, fileName, 'text/markdown');
        
        return { success: true, fileName, count: summaries.length };
    }

    exportBatchToJSON(summaries) {
        const data = {
            summaries,
            exportedAt: new Date().toISOString(),
            count: summaries.length,
            version: '1.0'
        };
        
        const fileName = `yt-summaries-batch-${Date.now()}.json`;
        this.downloadTextFile(
            JSON.stringify(data, null, 2), 
            fileName, 
            'application/json'
        );
        
        return { success: true, fileName, count: summaries.length };
    }

    // Helper methods
    downloadTextFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
    }

    generateFileName(title, extension) {
        // Clean title for filename
        const cleanTitle = (title || 'youtube-summary')
            .replace(/[^a-zA-Z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .toLowerCase()
            .substring(0, 50);
        
        const timestamp = new Date().toISOString().split('T')[0];
        return `${cleanTitle}-${timestamp}.${extension}`;
    }

    formatSummaryType(type) {
        const typeMap = {
            'bullet-points': 'Bullet Points',
            'paragraph': 'Paragraph',
            'outline': 'Outline',
            'qa': 'Q&A Format',
            'timeline': 'Timeline',
            'mindmap': 'Mind Map'
        };
        return typeMap[type] || type;
    }

    async addSummaryToPDF(doc, summary, margin, startY) {
        const pageWidth = doc.internal.pageSize.getWidth();
        const contentWidth = pageWidth - (margin * 2);
        let currentY = startY;
        
        // Add summary details (similar to single export logic)
        doc.setFontSize(12);
        
        if (summary.title) {
            doc.setFont(undefined, 'bold');
            doc.text('Title:', margin, currentY);
            doc.setFont(undefined, 'normal');
            const titleLines = doc.splitTextToSize(summary.title, contentWidth - 30);
            doc.text(titleLines, margin + 30, currentY);
            currentY += (titleLines.length * 5) + 5;
        }
        
        if (summary.channel) {
            doc.setFont(undefined, 'bold');
            doc.text('Channel:', margin, currentY);
            doc.setFont(undefined, 'normal');
            doc.text(summary.channel, margin + 35, currentY);
            currentY += 8;
        }
        
        currentY += 10;
        
        // Summary content
        doc.setFont(undefined, 'bold');
        doc.text('Summary:', margin, currentY);
        currentY += 8;
        
        doc.setFont(undefined, 'normal');
        doc.setFontSize(10);
        
        const summaryLines = doc.splitTextToSize(summary.content, contentWidth);
        summaryLines.forEach(line => {
            if (currentY > doc.internal.pageSize.getHeight() - margin) {
                doc.addPage();
                currentY = margin;
            }
            doc.text(line, margin, currentY);
            currentY += 4;
        });
    }

    // Copy summary to clipboard
    async copyToClipboard(summaryData) {
        try {
            let text = `${summaryData.title}\n`;
            text += `Channel: ${summaryData.channel}\n`;
            text += `URL: ${summaryData.url}\n\n`;
            text += summaryData.content;
            
            await navigator.clipboard.writeText(text);
            return { success: true };
        } catch (error) {
            console.error('Clipboard copy error:', error);
            throw error;
        }
    }

    // Share summary (if Web Share API is available)
    async shareSummary(summaryData) {
        if (navigator.share) {
            try {
                await navigator.share({
                    title: `Summary: ${summaryData.title}`,
                    text: summaryData.content,
                    url: summaryData.url
                });
                return { success: true };
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Share error:', error);
                }
                throw error;
            }
        } else {
            throw new Error('Web Share API not supported');
        }
    }
}

if(typeof module !== 'undefined' && module.exports) {
    module.exports = ExportManager;
} else {
    window.ExportManager = ExportManager;
}